<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Coin Collector — Client</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; font-family: Inter, system-ui, sans-serif; background:#0b0b0b; color:#eee; }
    #ui { display:flex; gap:12px; padding:12px; align-items:center; }
    canvas { background:#121212; display:block; margin:12px auto; border:1px solid #222; }
    #status { font-size:14px; }
    #scoreboard { margin-left:auto; }
    .lobby { font-size:14px; }
    .btn { background:#222; border:1px solid #333; color:#eee; padding:6px 10px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="status">Connecting...</div>
    <div class="lobby" id="lobby">Lobby: —</div>
    <div id="scoreboard">Scores: —</div>
  </div>
  <canvas id="c" width="800" height="600"></canvas>

<script>
// client.html — polished client with lobby, prediction, interpolation & reconciliation
const socket = new WebSocket('ws://localhost:8080');
let playerId = null;
let map = { w:800, h:600 };
let connected = false;

// local state and prediction
const local = { x: map.w/2, y: map.h/2, vx:0, vy:0 };
let inputs = { up:false, down:false, left:false, right:false };
let inputSeq = 0;
let pendingInputs = []; // inputs sent but not yet confirmed by server

// interpolation buffer
let snapshots = [];
let remotePlayers = {};
let coins = {};
let scores = {};

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// nice readable text
ctx.font = '12px monospace';

const SPEED = 160; // px/s
const PICKUP_RADIUS = 24;

// UI elements
const statusEl = document.getElementById('status');
const lobbyEl = document.getElementById('lobby');
const scoreboardEl = document.getElementById('scoreboard');

// send input to server (include client time for debugging)
function sendInput() {
  inputSeq++;
  const msg = { type:'input', seq: inputSeq, inputs: {...inputs}, clientTime: Date.now() };
  socket.send(JSON.stringify(msg));
  // store pending input for local prediction and reconciliation
  pendingInputs.push(msg);
}

// apply an input to a state (for replay)
function applyInputToState(state, inp, dt) {
  let ax=0, ay=0;
  if (inp.up) ay -=1;
  if (inp.down) ay +=1;
  if (inp.left) ax -=1;
  if (inp.right) ax +=1;
  const len = Math.hypot(ax, ay) || 1;
  state.vx = (ax/len) * SPEED;
  state.vy = (ay/len) * SPEED;
  state.x += state.vx * dt;
  state.y += state.vy * dt;
  state.x = Math.max(0, Math.min(map.w, state.x));
  state.y = Math.max(0, Math.min(map.h, state.y));
}

socket.addEventListener('open', () => {
  connected = true; statusEl.innerText = 'Connected — waiting in lobby';
});

socket.addEventListener('message', (ev) => {
  const data = JSON.parse(ev.data);
  if (data.type === 'welcome') {
    playerId = data.playerId; map = data.map; statusEl.innerText = `You are P${playerId}`;
    // place local at center
    local.x = map.w/2; local.y = map.h/2;
  } else if (data.type === 'lobby') {
    lobbyEl.innerText = 'Lobby: ' + data.players.map(p=>`P${p.id}`).join(', ');
    if (data.players.length >= 2) statusEl.innerText = 'Game starting...';
  } else if (data.type === 'snapshot') {
    // implement snapshot buffer with serverTime
    snapshots.push(data);
    // keep reasonable buffer length
    if (snapshots.length > 30) snapshots.shift();
    // Also, use this snapshot to reconcile local predicted state for player
    const latest = data; // most recent snapshot (server authoritative)
    // find our player record in snapshot
    const playerRecord = latest.players.find(p => p.id === playerId);
    if (playerRecord) {
      // Optional improvement: If server sent lastProcessedInputSeq, use it to trim pendingInputs:
      // pendingInputs = pendingInputs.filter(i => i.seq > playerRecord.lastProcessedInputSeq)
      // (server currently doesn't send lastProcessedInputSeq; consider adding it.)
      // reconcile: if server pos differs significantly from local predicted, correct via smooth snap
      const serverPos = { x: playerRecord.x, y: playerRecord.y };
      const dx = serverPos.x - local.x;
      const dy = serverPos.y - local.y;
      const dist2 = dx*dx + dy*dy;
      if (dist2 > 36*36) {
        // major divergence — snap toward server smoothly
        local.x += dx * 0.5;
        local.y += dy * 0.5;
      } else if (dist2 > 2*2) {
        // small divergence — smooth correction
        local.x += dx * 0.15;
        local.y += dy * 0.15;
      }
      scores[playerId] = playerRecord.score;
    }
    // update coins and remote players for immediate display (but we also interpolate)
    coins = {};
    latest.coins.forEach(c => coins[c.id] = c);
    latest.players.forEach(p => {
      if (p.id !== playerId) remotePlayers[p.id] = { x: p.x, y: p.y, vx: p.vx, vy: p.vy, score: p.score };
      else scores[p.id] = p.score;
    });
  } else if (data.type === 'pickup') {
    // play pickup sound or flash
    console.log('pickup event', data);
  }
});

// input handling
window.addEventListener('keydown', (e) => {
  let changed = false;
  if (e.key === 'ArrowUp' || e.key === 'w') { if (!inputs.up) { inputs.up=true; changed=true; } }
  if (e.key === 'ArrowDown' || e.key === 's') { if (!inputs.down) { inputs.down=true; changed=true; } }
  if (e.key === 'ArrowLeft' || e.key === 'a') { if (!inputs.left) { inputs.left=true; changed=true; } }
  if (e.key === 'ArrowRight' || e.key === 'd') { if (!inputs.right) { inputs.right=true; changed=true; } }
  if (changed) sendInput();
});
window.addEventListener('keyup', (e) => {
  let changed = false;
  if (e.key === 'ArrowUp' || e.key === 'w') { if (inputs.up) { inputs.up=false; changed=true; } }
  if (e.key === 'ArrowDown' || e.key === 's') { if (inputs.down) { inputs.down=false; changed=true; } }
  if (e.key === 'ArrowLeft' || e.key === 'a') { if (inputs.left) { inputs.left=false; changed=true; } }
  if (e.key === 'ArrowRight' || e.key === 'd') { if (inputs.right) { inputs.right=false; changed=true; } }
  if (changed) sendInput();
});

// render interpolation
const INTERP_DELAY = 220; // ms
function interpolateToRenderTime() {
  const renderTime = Date.now() - INTERP_DELAY;
  if (snapshots.length < 2) return;
  // find two snapshots that bracket renderTime
  let i = snapshots.length - 1;
  while (i > 0 && snapshots[i].serverTime > renderTime) i--;
  if (i >= snapshots.length-1) {
    applySnapshot(snapshots[snapshots.length-1]);
    return;
  }
  const s1 = snapshots[i], s2 = snapshots[i+1];
  const t = (renderTime - s1.serverTime) / (s2.serverTime - s1.serverTime || 1);
  // interpolate players
  s1.players.forEach(p1 => {
    const p2 = s2.players.find(pp=>pp.id===p1.id);
    if (!p2) return;
    const ix = p1.x + (p2.x - p1.x) * t;
    const iy = p1.y + (p2.y - p1.y) * t;
    if (p1.id === playerId) {
      // reconcile small differences
      const dx = ix - local.x, dy = iy - local.y;
      local.x += dx * 0.08; local.y += dy * 0.08;
      scores[playerId] = p2.score;
    } else {
      remotePlayers[p1.id] = { x: ix, y: iy, score: p2.score };
    }
  });
  // update coins
  coins = {};
  s2.coins.forEach(c => coins[c.id] = c);
}
function applySnapshot(s) {
  s.players.forEach(p => {
    if (p.id === playerId) {
      const dx = p.x - local.x; const dy = p.y - local.y;
      local.x += dx*0.1; local.y += dy*0.1;
      scores[playerId] = p.score;
    } else {
      remotePlayers[p.id] = { x:p.x, y:p.y, score:p.score };
    }
  });
  coins = {};
  s.coins.forEach(c => coins[c.id] = c);
}

// main loop
let last = Date.now();
function loop() {
  const now = Date.now();
  const dt = (now - last)/1000; last = now;
  // client-side prediction: reapply last known inputs for smooth local motion
  if (pendingInputs.length > 0) {
    // apply the latest pending input for a small dt
    const latest = pendingInputs[pendingInputs.length-1];
    applyInputToState(local, latest.inputs, dt);
  } else {
    // no input — damp velocity
    local.vx *= 0.9; local.vy *= 0.9;
    local.x += local.vx * dt; local.y += local.vy * dt;
  }

  // interpolation for remote
  interpolateToRenderTime();

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // coins
  for (const id in coins) {
    const c = coins[id];
    ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(c.x, c.y, 8,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.fillText(`#${c.id}`, c.x-10, c.y+3);
  }
  // remote players
  for (const id in remotePlayers) {
    const p = remotePlayers[id];
    ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.fillText(`P${id}`, p.x-10, p.y-18);
  }
  // local player
  ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.arc(local.x, local.y, 12, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.fillText(`You (P${playerId||'?'})`, local.x-18, local.y-18);

  // scoreboard
  const scoreText = Object.keys(scores).sort().map(k=>`P${k}:${scores[k]||0}`).join(' | ');
  scoreboardEl.innerText = scoreText || 'Scores: —';

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
